# -*- coding: utf-8 -*-
"""MentorEducacional-rev2p1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qYRz-n_idogS3VCqawIFUuVihJWlUvzg
"""

# --- Instala√ß√£o de Bibliotecas ---
!pip install pandas openpyxl ics PyPDF2 google-generativeai -q

# --- Importa√ß√µes Necess√°rias ---
import json
import os
from google.colab import drive, files
from google.colab import userdata # Para acessar segredos do Colab
import io
import PyPDF2
import google.generativeai as genai
import pandas as pd
from ics import Calendar, Event
from datetime import datetime, timedelta, time
import re # Para ajudar a extrair JSON da resposta da LLM
import textwrap # NOVA IMPORTA√á√ÉO

# --- M√≥dulo 0: Gerenciador de Dados do Aluno ---
DRIVE_MOUNTED = False
DRIVE_BASE_PATH = '/content/drive/MyDrive/DadosAlunosColab/' # Caminho padr√£o no Drive

def mount_drive():
    global DRIVE_MOUNTED, DRIVE_BASE_PATH
    if DRIVE_MOUNTED:
        return
    try:
        drive.mount('/content/drive')
        os.makedirs(DRIVE_BASE_PATH, exist_ok=True)
        DRIVE_MOUNTED = True
        print("Google Drive montado com sucesso.")
    except Exception as e:
        print(f"Erro ao montar o Google Drive: {e}. Usando armazenamento local para esta sess√£o.")
        DRIVE_BASE_PATH = './DadosAlunosColab_local/'
        os.makedirs(DRIVE_BASE_PATH, exist_ok=True)
        DRIVE_MOUNTED = False

def get_student_data_path(student_id):
    return os.path.join(DRIVE_BASE_PATH, f'{student_id}.json')

def save_student_data(student_id, data):
    file_path = get_student_data_path(student_id)
    try:
        with open(file_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, indent=4, ensure_ascii=False)
        print(f"Dados do aluno {student_id} salvos em {file_path}")
    except Exception as e:
        print(f"Erro ao salvar dados do aluno {student_id}: {e}")

def load_student_data(student_id):
    file_path = get_student_data_path(student_id)
    if os.path.exists(file_path):
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                data = json.load(f)
            return data
        except Exception as e:
            print(f"Erro ao carregar dados do aluno {student_id}: {e}")
            return {}
    else:
        return {}

# --- M√≥dulo 1: Agente de Curr√≠culo (BNCC) ---
bncc_topics_data = {
    'Ensino M√©dio': {
        '1¬™ S√©rie': {
            'Matem√°tica': [
                {'codigo': 'EM13MAT101', 'descricao': 'Interpretar criticamente situa√ß√µes econ√¥micas, sociais e das Ci√™ncias da Natureza que envolvam a varia√ß√£o de grandezas...'},
                {'codigo': 'EM13MAT102', 'descricao': 'Analisar tabelas, gr√°ficos e informa√ß√µes para tomar decis√µes...'},
            ],
            'L√≠ngua Portuguesa': [
                {'codigo': 'EM13LP01', 'descricao': 'Relacionar o texto, tanto na produ√ß√£o como na leitura/escuta, com suas condi√ß√µes de produ√ß√£o e seu contexto s√≥cio-hist√≥rico...'},
            ]
        },
        '2¬™ S√©rie': {
            'Hist√≥ria': [
                {'codigo': 'EM13CHS101', 'descricao': 'Analisar e comparar diferentes narrativas expressas em diversas linguagens...'},
                {'codigo': 'EM13CHS102', 'descricao': 'Identificar, analisar e discutir as circunst√¢ncias hist√≥ricas, geogr√°ficas, pol√≠ticas, econ√¥micas, sociais, ambientais e culturais de matrizes conceituais...'}
            ],
            'L√≠ngua Portuguesa': [
                {'codigo': 'EM13LP02', 'descricao': 'Analisar modos de organiza√ß√£o da sociedade contempor√¢nea...'},
                {'codigo': 'EM13LP03', 'descricao': 'Analisar criticamente discursos e pr√°ticas sociais, considerando diferentes pontos de vista...'}
            ],
            'Matem√°tica': [
                {'codigo': 'EM13MAT201', 'descricao': 'Propor ou participar de a√ß√µes para investigar desafios do mundo contempor√¢neo...'},
                {'codigo': 'EM13MAT202', 'descricao': 'Planejar e executar pesquisa amostral sobre quest√µes relevantes...'}
            ],
            'Qu√≠mica': [
                 {'codigo': 'EM13CNT202', 'descricao': 'Analisar as diversas formas de manifesta√ß√£o da vida em seus diferentes n√≠veis de organiza√ß√£o...'},
                 {'codigo': 'EM13CNT203', 'descricao': 'Avaliar e prever efeitos de interven√ß√µes nos ecossistemas...'}
            ]
        },
        '3¬™ S√©rie': {
             # Adicionar t√≥picos para a 3¬™ s√©rie conforme necess√°rio
        }
    }
}

def get_bncc_topics(serie_aluno, disciplina=None):
    nivel_ensino = 'Ensino M√©dio'
    if nivel_ensino in bncc_topics_data and serie_aluno in bncc_topics_data[nivel_ensino]:
        serie_data = bncc_topics_data[nivel_ensino][serie_aluno]
        if disciplina:
            # Normalizar nome da disciplina para busca
            disciplina_norm = disciplina.strip().title()
            return serie_data.get(disciplina_norm, [])
        else:
            all_topics = []
            for disc_topics in serie_data.values():
                all_topics.extend(disc_topics)
            return all_topics
    return []

# --- Configura√ß√£o da API do Google Gemini ---
GOOGLE_API_KEY = None
GEMINI_MODEL = None
SAFETY_SETTINGS = [ # Configura√ß√µes de seguran√ßa mais permissivas
    {"category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_NONE"},
    {"category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_NONE"},
    {"category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_NONE"},
    {"category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_NONE"},
]
try:
    GOOGLE_API_KEY = userdata.get('GOOGLE_API_KEY')
    if GOOGLE_API_KEY:
        genai.configure(api_key=GOOGLE_API_KEY)
        GEMINI_MODEL = genai.GenerativeModel('gemini-1.5-flash-latest', safety_settings=SAFETY_SETTINGS)
        print("API do Google Gemini configurada com sucesso.")
    else:
        print("Chave de API do Google (GOOGLE_API_KEY) est√° vazia nos Segredos do Colab. A op√ß√£o de an√°lise de PDF via LLM estar√° desabilitada.")
        GOOGLE_API_KEY = None
except userdata.SecretNotFoundError:
    print("Chave de API do Google (GOOGLE_API_KEY) n√£o encontrada nos Segredos do Colab. A op√ß√£o de an√°lise de PDF via LLM estar√° desabilitada.")
    GOOGLE_API_KEY = None
except Exception as e:
    print(f"Erro ao configurar a API do Google Gemini: {e}. Verifique se os segredos est√£o habilitados e a chave est√° correta. A op√ß√£o de an√°lise de PDF via LLM estar√° desabilitada.")
    GOOGLE_API_KEY = None


# --- M√≥dulo 2: Intera√ß√£o Inicial e Coleta de Dados Acad√™micos ---

def collect_initial_info():
    print("üéì Bem-vindo(a) ao Mentor Educacional Personalizado! üòä")
    student_id_input = input("Para come√ßarmos, qual √© o seu primeiro nome (usaremos como identificador)? ").strip()
    student_id = student_id_input if student_id_input else "aluno_padrao"
    if not student_id_input: print(f"Usando identificador padr√£o: {student_id}")

    student_data = load_student_data(student_id)

    if not student_data:
        print(f"\nOl√°, {student_id}! Parece que √© nossa primeira conversa.")
        student_data['id'] = student_id
        student_data['nome'] = student_id
        while True:
            serie = input("Qual s√©rie do Ensino M√©dio voc√™ est√° cursando (1¬™ S√©rie, 2¬™ S√©rie ou 3¬™ S√©rie)? ").strip().title()
            if serie in ["1¬™ S√©rie", "2¬™ S√©rie", "3¬™ S√©rie"]:
                student_data['serie'] = serie
                break
            else:
                print("S√©rie inv√°lida. Por favor, use '1¬™ S√©rie', '2¬™ S√©rie' ou '3¬™ S√©rie'.")
        student_data['disciplinas'] = {}
        print(f"√ìtimo, {student_data['nome']} da {student_data['serie']}!")
    else:
        print(f"\nOl√° de volta, {student_data.get('nome', student_id)}!")
        print(f"S√©rie registrada: {student_data.get('serie', 'N√£o informada')}")
        confirm_serie = input("A s√©rie est√° correta? (S/N): ").strip().lower()
        if confirm_serie != 's':
            while True:
                serie = input("Qual a s√©rie correta (1¬™ S√©rie, 2¬™ S√©rie ou 3¬™ S√©rie)? ").strip().title()
                if serie in ["1¬™ S√©rie", "2¬™ S√©rie", "3¬™ S√©rie"]:
                    student_data['serie'] = serie
                    break
                else:
                    print("S√©rie inv√°lida.")

    save_student_data(student_id, student_data)
    return student_id, student_data

def extract_json_from_llm_response(llm_text_response):
    match = re.search(r"```json\s*([\s\S]*?)\s*```", llm_text_response, re.IGNORECASE)
    json_string = None
    if match:
        json_string = match.group(1)
    else:
        json_start = llm_text_response.find('{')
        json_end = llm_text_response.rfind('}')
        if json_start != -1 and json_end != -1 and json_end > json_start:
            json_string = llm_text_response[json_start : json_end + 1]

    if json_string:
        try:
            return json.loads(json_string)
        except json.JSONDecodeError as e:
            print(f"Falha ao decodificar o JSON extra√≠do da resposta da LLM: {e}")
            print(f"String JSON problem√°tica: {json_string[:500]}...")
            return None
    print("Nenhum JSON v√°lido encontrado na resposta da LLM.")
    return None

def process_pdf_with_llm(pdf_content):
    if not GEMINI_MODEL:
        print("LLM n√£o est√° configurada. N√£o √© poss√≠vel processar o PDF.")
        return None
    try:
        reader = PyPDF2.PdfReader(io.BytesIO(pdf_content))
        pdf_text = ""
        if not reader.pages:
            print("Erro: O PDF n√£o cont√©m p√°ginas ou n√£o p√¥de ser lido.")
            return None
        for page_num in range(len(reader.pages)):
            page = reader.pages[page_num]
            page_text = page.extract_text()
            if page_text:
                pdf_text += page_text + "\n--- Fim da P√°gina ---\n"

        if not pdf_text.strip():
            print("N√£o foi poss√≠vel extrair texto do PDF. Pode ser um PDF de imagem ou estar vazio.")
            return None

        print("\nEnviando texto do PDF para an√°lise pela LLM (isso pode levar um momento)...")
        prompt = f"""
        Voc√™ √© um assistente especialista em extrair dados acad√™micos de boletins escolares do Ensino M√©dio brasileiro.
        Analise o texto do boletim a seguir e extraia as seguintes informa√ß√µes para CADA disciplina.
        Se uma avalia√ß√£o se chamar "Prova Final", "PF", "Exame Final" ou similar, identifique-a claramente.
        1.  Nome da Disciplina (ex: "Matem√°tica", "L√≠ngua Portuguesa"). Use nomes padronizados e com capitaliza√ß√£o de t√≠tulo.
        2.  M√©dia m√≠nima para aprova√ß√£o na disciplina (se expl√≠cito, caso contr√°rio, use 6.0 como padr√£o).
        3.  Uma lista de avalia√ß√µes, contendo para cada avalia√ß√£o:
            a.  "nome": Nome da avalia√ß√£o (ex: "P1", "Trabalho Bimestral", "Prova Final"). Padronize "Prova Final" se aplic√°vel.
            b.  "peso": Peso percentual da avalia√ß√£o (ex: 0.3 para 30%). Se n√£o expl√≠cito, tente estimar ou deixe como null. A soma dos pesos por disciplina DEVE ser 1.0 (ou 100%). Se os pesos extra√≠dos n√£o somarem 1.0, normalize-os ou indique um problema na extra√ß√£o.
            c.  "nota": Nota obtida pelo aluno (n√∫mero). Se n√£o realizada ou n√£o informada, deixe como null.
            d.  "faltante": true se a nota for null, false caso contr√°rio.
            e.  "is_pf": true se esta avalia√ß√£o for a Prova Final/Exame Final, false caso contr√°rio.
        4.  F√≥rmula de c√°lculo da m√©dia final da disciplina (se expl√≠cita, ex: "(P1*0.3)+(TG*0.2)+(PF*0.5)"). Se n√£o, use "ponderada".

        Retorne as informa√ß√µes APENAS no seguinte formato JSON:
        {{
          "disciplinas": {{
            "Nome da Disciplina 1": {{
              "media_minima": 6.0,
              "avaliacoes": [
                {{"nome": "P1", "peso": 0.3, "nota": 7.5, "faltante": false, "is_pf": false}},
                {{"nome": "Trabalho", "peso": 0.2, "nota": 8.0, "faltante": false, "is_pf": false}},
                {{"nome": "Prova Final", "peso": 0.5, "nota": null, "faltante": true, "is_pf": true}}
              ],
              "formula": "(P1*0.3)+(Trabalho*0.2)+(PF*0.5)"
            }}
          }}
        }}
        Se n√£o conseguir extrair informa√ß√µes de forma estruturada, retorne um objeto JSON com "disciplinas": {{}}.
        Texto do Boletim:
        ---
        {pdf_text}
        ---
        """
        response = GEMINI_MODEL.generate_content(prompt)
        print("\nResposta da LLM recebida.")
        extracted_data = extract_json_from_llm_response(response.text)

        if extracted_data and "disciplinas" in extracted_data:
            print("Dados JSON extra√≠dos e analisados com sucesso pela LLM.")
            normalized_disciplinas = {}
            for disc_nome_raw, disc_data in extracted_data["disciplinas"].items():
                disc_nome_norm = disc_nome_raw.strip().title()
                disc_data_normalized_avals = []
                if 'avaliacoes' in disc_data:
                    for aval in disc_data.get('avaliacoes', []):
                        aval['nome'] = aval.get('nome', 'Avalia√ß√£o Desconhecida').strip().title()
                        aval['is_pf'] = aval.get('is_pf', False)
                        if "prova final" in aval['nome'].lower() or "exame final" in aval['nome'].lower() or "pf" == aval['nome'].lower():
                            aval['is_pf'] = True
                        disc_data_normalized_avals.append(aval)
                    disc_data['avaliacoes'] = disc_data_normalized_avals

                current_sum_pesos = sum(aval.get('peso', 0) or 0 for aval in disc_data.get('avaliacoes', []))
                if current_sum_pesos > 0 and abs(current_sum_pesos - 1.0) > 1e-2:
                    print(f"Aviso LLM: Pesos para '{disc_nome_norm}' somam {current_sum_pesos*100:.1f}%. Isso precisar√° ser corrigido na valida√ß√£o.")

                disc_data['avaliacoes_faltantes'] = [
                    aval['nome'] for aval in disc_data.get('avaliacoes', []) if (aval.get('faltante', True) or aval.get('nota') is None) and not aval.get('is_pf', False)
                ]
                normalized_disciplinas[disc_nome_norm] = disc_data
            extracted_data["disciplinas"] = normalized_disciplinas
            return extracted_data
        else:
            print("N√£o foi poss√≠vel extrair dados estruturados da resposta da LLM no formato esperado.")
            print("Resposta da LLM:", response.text[:500] + "..." if response.text else "Nenhuma resposta")
            return None
    except PyPDF2.errors.PdfReadError as pdf_err:
        print(f"Erro ao ler o arquivo PDF: {pdf_err}. O arquivo pode estar corrompido ou protegido.")
        return None
    except Exception as e:
        print(f"Erro durante o processamento do PDF ou intera√ß√£o com a LLM: {e}")
        return None

def collect_academic_info_manual(student_id, student_data):
    print("\n--- Preenchimento Manual de Informa√ß√µes Acad√™micas ---")
    if 'disciplinas' not in student_data: student_data['disciplinas'] = {}

    while True:
        disciplina_nome = input("Nome da Disciplina (ou 'fim' para terminar): ").strip()
        if disciplina_nome.lower() == 'fim': break

        disciplina_nome_norm = disciplina_nome.title()

        if disciplina_nome_norm not in student_data['disciplinas']:
            student_data['disciplinas'][disciplina_nome_norm] = {'avaliacoes': [], 'formula': 'ponderada', 'media_minima': 6.0}
        disciplina_atual = student_data['disciplinas'][disciplina_nome_norm]

        while True:
            try:
                media_min_str = input(f"  M√©dia m√≠nima para aprova√ß√£o em {disciplina_nome_norm} (atual: {disciplina_atual.get('media_minima', '6.0')}): ").strip()
                if media_min_str: disciplina_atual['media_minima'] = float(media_min_str)
                elif disciplina_atual.get('media_minima') is None:
                    disciplina_atual['media_minima'] = 6.0
                break
            except ValueError: print("    Entrada inv√°lida.")

        formula_atual = disciplina_atual.get('formula', 'ponderada')
        nova_formula = input(f"  F√≥rmula de c√°lculo da m√©dia (atual: '{formula_atual}', ex: '(P1*0.3)+(P2*0.5)', 'ponderada'): ").strip()
        if nova_formula: disciplina_atual['formula'] = nova_formula

        print("  Estrutura de avalia√ß√£o:")
        edit_avals_choice = input(f"  Existem {len(disciplina_atual.get('avaliacoes',[]))} avalia√ß√µes registradas para '{disciplina_nome_norm}'. Deseja (R)einserir todas, (A)dicionar novas ou (M)anter? (R/A/M): ").strip().lower()

        if edit_avals_choice == 'r':
            disciplina_atual['avaliacoes'] = []

        if edit_avals_choice in ['r', 'a']:
            while True:
                aval_nome_input = input("    Nome da avalia√ß√£o (ou 'fim' para concluir esta disciplina): ").strip()
                if aval_nome_input.lower() == 'fim': break
                if not aval_nome_input: print("     Nome da avalia√ß√£o n√£o pode ser vazio."); continue

                aval_nome_norm = aval_nome_input.title()
                is_pf_input = input(f"    '{aval_nome_norm}' √© a Prova Final (PF)? (S/N): ").strip().lower()
                is_pf_aval = (is_pf_input == 's')

                aval_peso_percent = -1.0
                while not (0.0 <= aval_peso_percent <= 100.0):
                    try:
                        aval_peso_percent = float(input(f"    Peso percentual de '{aval_nome_norm}' (ex: 30 para 30%): "))
                        if not (0.0 <= aval_peso_percent <= 100.0): print("      Peso deve ser entre 0 e 100.")
                    except ValueError: print("      Entrada inv√°lida para peso.")

                nota_str = input(f"    Nota obtida em '{aval_nome_norm}' (deixe em branco se ainda n√£o feita): ").strip()
                nota, faltante = (None, True)
                if nota_str:
                    try: nota, faltante = (float(nota_str), False)
                    except ValueError: print("      Nota inv√°lida, ser√° considerada como n√£o realizada.")

                existing_aval_idx = next((idx for idx, a in enumerate(disciplina_atual.get('avaliacoes',[])) if a['nome'].title() == aval_nome_norm), -1)
                new_aval_data = {'nome': aval_nome_norm, 'peso': aval_peso_percent / 100.0, 'nota': nota, 'faltante': faltante, 'is_pf': is_pf_aval}

                if existing_aval_idx != -1:
                    if edit_avals_choice == 'r':
                         disciplina_atual['avaliacoes'][existing_aval_idx] = new_aval_data
                         print(f"      Avalia√ß√£o '{aval_nome_norm}' substitu√≠da (modo reinserir).")
                    else:
                         print(f"      Aten√ß√£o: Avalia√ß√£o '{aval_nome_norm}' j√° existe. Se desejava editar, escolha (R)einserir para a disciplina ou edite na etapa de valida√ß√£o.")
                else:
                    disciplina_atual['avaliacoes'].append(new_aval_data)
                    print(f"      Avalia√ß√£o '{aval_nome_norm}' adicionada.")

        soma_pesos_final_disciplina = sum(aval.get('peso', 0) or 0 for aval in disciplina_atual.get('avaliacoes', []))
        if abs(soma_pesos_final_disciplina - 1.0) > 1e-3 and soma_pesos_final_disciplina > 0:
            print(f"  Aten√ß√£o: O peso total das avalia√ß√µes para '{disciplina_nome_norm}' √© {soma_pesos_final_disciplina*100:.1f}%. Idealmente, deveria ser 100%.")

        disciplina_atual['avaliacoes_faltantes'] = [a['nome'] for a in disciplina_atual.get('avaliacoes', []) if (a.get('faltante', True) or a.get('nota') is None) and not a.get('is_pf',False)]
        print(f"  Informa√ß√µes de '{disciplina_nome_norm}' atualizadas.")

    save_student_data(student_id, student_data)
    return student_data

def merge_llm_data_with_student_data(student_data_existing, llm_extracted_data, replace_all_disciplines=False):
    if not llm_extracted_data or 'disciplinas' not in llm_extracted_data:
        print("LLM: Nenhum dado de disciplina v√°lido para mesclar.")
        return student_data_existing

    llm_disciplinas = llm_extracted_data['disciplinas'] # J√° normalizado em process_pdf_with_llm

    if replace_all_disciplines:
        print("LLM: Substituindo todas as disciplinas existentes pelos dados extra√≠dos do PDF.")
        student_data_existing['disciplinas'] = llm_disciplinas # Atribui√ß√£o direta
    else:
        if 'disciplinas' not in student_data_existing:
            student_data_existing['disciplinas'] = {}

        for llm_disc_nome, llm_disc_data in llm_disciplinas.items():
            # llm_disc_nome j√° est√° normalizado
            matched_disc_name_in_student_data = None
            for s_disc_name_key in student_data_existing['disciplinas'].keys():
                if s_disc_name_key == llm_disc_nome: # Compara√ß√£o direta de nomes normalizados
                    matched_disc_name_in_student_data = s_disc_name_key
                    break

            if not matched_disc_name_in_student_data:
                student_data_existing['disciplinas'][llm_disc_nome] = llm_disc_data
                print(f"LLM: Adicionando nova disciplina '{llm_disc_nome}'.")
            else:
                print(f"LLM: Mesclando dados para disciplina existente '{matched_disc_name_in_student_data}'.")
                current_disc = student_data_existing['disciplinas'][matched_disc_name_in_student_data]

                if llm_disc_data.get('media_minima') is not None and current_disc.get('media_minima') is None:
                    current_disc['media_minima'] = llm_disc_data['media_minima']
                if llm_disc_data.get('formula', 'ponderada') != 'ponderada' and current_disc.get('formula', 'ponderada') == 'ponderada':
                    current_disc['formula'] = llm_disc_data['formula']

                if 'avaliacoes' not in current_disc: current_disc['avaliacoes'] = []
                current_avals_map = {aval['nome']: aval for aval in current_disc.get('avaliacoes', [])} # Nomes j√° normalizados

                for llm_aval in llm_disc_data.get('avaliacoes', []):
                    # llm_aval['nome'] j√° normalizado
                    if llm_aval['nome'] not in current_avals_map:
                        current_disc['avaliacoes'].append(llm_aval)
                        print(f"  LLM: Adicionando nova avalia√ß√£o '{llm_aval['nome']}' para '{matched_disc_name_in_student_data}'.")
                    else:
                        existing_aval_in_map = current_avals_map[llm_aval['nome']]
                        if existing_aval_in_map.get('faltante', True) and not llm_aval.get('faltante', True) and llm_aval.get('nota') is not None:
                            existing_aval_in_map['nota'] = llm_aval['nota']
                            existing_aval_in_map['faltante'] = False
                            print(f"  LLM: Atualizando nota para avalia√ß√£o existente '{llm_aval['nome']}'.")
                        if existing_aval_in_map.get('peso') is None and llm_aval.get('peso') is not None:
                            existing_aval_in_map['peso'] = llm_aval.get('peso')
                            print(f"  LLM: Adicionando peso para avalia√ß√£o existente '{llm_aval['nome']}'.")
                        if existing_aval_in_map.get('is_pf') is None and llm_aval.get('is_pf') is not None:
                             existing_aval_in_map['is_pf'] = llm_aval.get('is_pf')

                current_disc['avaliacoes_faltantes'] = [
                    aval['nome'] for aval in current_disc.get('avaliacoes', []) if (aval.get('faltante', True) or aval.get('nota') is None) and not aval.get('is_pf', False)
                ]
    return student_data_existing


def display_extracted_pdf_data_for_confirmation(llm_extracted_data):
    print("\n--- Dados Extra√≠dos do PDF pela LLM ---")
    if not llm_extracted_data or 'disciplinas' not in llm_extracted_data or not llm_extracted_data['disciplinas']:
        print("Nenhuma disciplina foi extra√≠da do PDF.")
        return False

    for disc_nome, disc_data in llm_extracted_data['disciplinas'].items():
        print(f"\nDisciplina: {disc_nome}") # J√° normalizado
        print(f"  M√©dia M√≠nima: {disc_data.get('media_minima', 'N√£o especificada')}")
        print(f"  F√≥rmula: {disc_data.get('formula', 'ponderada')}")
        print("  Avalia√ß√µes:")
        if disc_data.get('avaliacoes'):
            for aval in disc_data['avaliacoes']:
                nota_str = f"{aval.get('nota'):.2f}" if isinstance(aval.get('nota'), (int, float)) else "N/A"
                peso_str = f"{aval.get('peso')*100:.1f}%" if isinstance(aval.get('peso'), (int, float)) else "N/A"
                is_pf_str = " (Prova Final)" if aval.get('is_pf') else ""
                print(f"    - Nome: {aval.get('nome', 'N/A')}{is_pf_str}, Peso: {peso_str}, Nota: {nota_str}, Faltante: {aval.get('faltante', True)}")
        else:
            print("    Nenhuma avalia√ß√£o encontrada para esta disciplina.")
    print("--------------------------------------")
    while True:
        confirm = input("Os dados extra√≠dos parecem corretos e voc√™ deseja us√°-los (substituindo os existentes)? (S/N): ").strip().lower()
        if confirm == 's':
            return True
        elif confirm == 'n':
            return False
        else:
            print("Op√ß√£o inv√°lida. Digite S ou N.")


def collect_academic_info(student_id, student_data):
    print("\nüóÇÔ∏è Passo 2 ‚Äì Coleta/Atualiza√ß√£o de Informa√ß√µes Acad√™micas")
    print("Para uma an√°lise precisa, preciso das suas notas e da estrutura de avalia√ß√£o.")

    data_collected_or_modified_in_this_step = False
    pdf_data_confirmed_and_used = False # Nova flag

    while True:
        print("\nEscolha uma op√ß√£o:")
        print("  A - Preencher/Editar Manualmente as informa√ß√µes das disciplinas.")
        if GOOGLE_API_KEY and GEMINI_MODEL:
            print("  B - Enviar boletim em PDF (isso SUBSTITUIR√Å as disciplinas atuais pelas do PDF).")
            valid_choices = ['A', 'B', 'F']
        else:
            print("  B - (Op√ß√£o de PDF indispon√≠vel - API LLM n√£o configurada).")
            valid_choices = ['A', 'F']
        print("  F - Finalizar coleta/edi√ß√£o e prosseguir para an√°lise.")

        choice = input("Sua escolha: ").strip().upper()

        if choice == 'F':
            break
        elif choice == 'A':
            student_data = collect_academic_info_manual(student_id, student_data)
            data_collected_or_modified_in_this_step = True
            pdf_data_confirmed_and_used = False
        elif choice == 'B' and GOOGLE_API_KEY and GEMINI_MODEL:
            print("\n--- Envio de Boletim (PDF) ---")
            print("Por favor, fa√ßa o upload do seu arquivo PDF.")
            print("AVISO: As informa√ß√µes extra√≠das deste PDF SUBSTITUIR√ÉO todas as disciplinas e notas anteriormente registradas, AP√ìS SUA CONFIRMA√á√ÉO.")

            try:
                uploaded = files.upload()
                if not uploaded:
                    print("Nenhum arquivo foi enviado.")
                    continue
                filename = list(uploaded.keys())[0]
                print(f'Arquivo "{filename}" enviado.')
                pdf_content = uploaded[filename]
            except Exception as e:
                print(f"Erro durante o upload do arquivo: {e}")
                continue

            llm_extracted_data = process_pdf_with_llm(pdf_content)

            if llm_extracted_data and llm_extracted_data.get("disciplinas"):
                if display_extracted_pdf_data_for_confirmation(llm_extracted_data):
                    student_data = merge_llm_data_with_student_data(student_data, llm_extracted_data, replace_all_disciplines=True)
                    save_student_data(student_id, student_data)
                    print("Dados extra√≠dos pela LLM foram aplicados, substituindo informa√ß√µes anteriores.")
                    data_collected_or_modified_in_this_step = True
                    pdf_data_confirmed_and_used = True
                else:
                    print("Extra√ß√£o do PDF cancelada pelo usu√°rio. Os dados anteriores foram mantidos.")
                    pdf_data_confirmed_and_used = False
            else:
                print("N√£o foi poss√≠vel extrair dados do PDF via LLM ou a extra√ß√£o falhou/retornou vazio.")
                pdf_data_confirmed_and_used = False
        elif choice not in valid_choices:
             print("Op√ß√£o inv√°lida.")
        else:
            print("Op√ß√£o inv√°lida ou indispon√≠vel.")

    if data_collected_or_modified_in_this_step and not pdf_data_confirmed_and_used and student_data.get('disciplinas'):
        print("\nAp√≥s a coleta/edi√ß√£o manual, vamos validar os dados para garantir a precis√£o.")
        student_data = validate_and_complement_data(student_id, student_data)
    elif pdf_data_confirmed_and_used:
        print("\nDados do PDF confirmados. Prosseguindo diretamente para a an√°lise.")
    elif not student_data.get('disciplinas') and data_collected_or_modified_in_this_step:
        print("\nNenhuma disciplina foi inserida ou modificada.")
    elif not student_data.get('disciplinas'):
        print("\nNenhuma disciplina carregada ou inserida para esta sess√£o.")


    print("Coleta/edi√ß√£o de informa√ß√µes acad√™micas finalizada.")
    return student_data


# --- M√≥dulo 3: Valida√ß√£o e Complementa√ß√£o dos Dados pelo Usu√°rio ---
def validate_and_complement_data(student_id, student_data):
    print("\nüìã Passo de Valida√ß√£o e Complementa√ß√£o dos Dados")
    print(f"Ol√°, {student_data.get('nome', student_id)}! Vamos revisar e, se necess√°rio, ajustar as informa√ß√µes das suas disciplinas.")

    if 'disciplinas' not in student_data or not student_data['disciplinas']:
        print("Nenhuma disciplina encontrada para validar. Por favor, adicione informa√ß√µes primeiro.")
        return student_data

    disciplinas_a_revisar = list(student_data['disciplinas'].keys())
    for disc_nome_original in disciplinas_a_revisar:
        if disc_nome_original not in student_data['disciplinas']:
            continue

        print(f"\n--- Validando Disciplina: {disc_nome_original} ---")
        disc_atual = student_data['disciplinas'][disc_nome_original]

        media_min_val = disc_atual.get('media_minima')
        while True:
            input_prompt = f"  M√©dia m√≠nima para aprova√ß√£o (atual: {media_min_val if media_min_val is not None else 'N√ÉO DEFINIDA (usando 6.0)'}, ex: 6.0): "
            nova_media_min_str = input(input_prompt).strip()
            if not nova_media_min_str and media_min_val is not None: break
            if not nova_media_min_str and media_min_val is None:
                disc_atual['media_minima'] = 6.0
                print("    Usando 6.0 como padr√£o para m√©dia m√≠nima.")
                break
            try:
                disc_atual['media_minima'] = float(nova_media_min_str)
                break
            except ValueError: print("    Valor inv√°lido para m√©dia m√≠nima. Use um n√∫mero (ex: 6.0).")

        formula_val = disc_atual.get('formula', 'ponderada')
        nova_formula = input(f"  F√≥rmula de c√°lculo da m√©dia (atual: '{formula_val}', ex: '(P1*0.3)+(P2*0.5)', 'ponderada'): ").strip()
        if nova_formula: disc_atual['formula'] = nova_formula

        print("  Avalia√ß√µes:")
        if 'avaliacoes' not in disc_atual: disc_atual['avaliacoes'] = []

        current_avals_list = disc_atual.get('avaliacoes', [])
        if not isinstance(current_avals_list, list): current_avals_list = []

        for i, aval in enumerate(current_avals_list):
            nota_display = f"{aval.get('nota', 'N/A'):.2f}" if isinstance(aval.get('nota'), float) else str(aval.get('nota', 'N/A'))
            peso_display = f"{(aval.get('peso', 0) or 0)*100:.1f}%"
            is_pf_str = " (Prova Final)" if aval.get('is_pf') else ""
            print(f"    {i+1}. Nome: {aval.get('nome', 'N/A')}{is_pf_str}, Peso: {peso_display}, Nota: {nota_display}, Faltante: {aval.get('faltante', True)}")

        edit_avals = input("  Deseja (R)einserir todas, (A)dicionar novas, (E)ditar uma existente, ou (M)anter as avalia√ß√µes para esta disciplina? (R/A/E/M): ").strip().lower()

        temp_avals_for_disc = list(disc_atual.get('avaliacoes', []))

        if edit_avals == 'r':
            temp_avals_for_disc = []
            print(f"  Reinserindo avalia√ß√µes para {disc_nome_original}:")
        elif edit_avals == 'a':
            print(f"  Adicionando novas avalia√ß√µes para {disc_nome_original}:")
        elif edit_avals == 'e':
            if not temp_avals_for_disc:
                print("    Nenhuma avalia√ß√£o para editar. Adicione uma primeiro.")
            else:
                while True:
                    try:
                        idx_to_edit_str = input(f"    Qual o n√∫mero da avalia√ß√£o para editar (1-{len(temp_avals_for_disc)})? (ou 'fim'): ")
                        if idx_to_edit_str.lower() == 'fim': break
                        idx_to_edit = int(idx_to_edit_str) - 1
                        if 0 <= idx_to_edit < len(temp_avals_for_disc):
                            aval_to_edit = temp_avals_for_disc[idx_to_edit]
                            print(f"    Editando '{aval_to_edit['nome']}':")

                            new_aval_nome = input(f"      Novo nome (atual: {aval_to_edit['nome']}): ").strip().title()
                            if new_aval_nome: aval_to_edit['nome'] = new_aval_nome

                            new_is_pf_input = input(f"      √â Prova Final? (atual: {'S' if aval_to_edit.get('is_pf') else 'N'}) (S/N): ").strip().lower()
                            if new_is_pf_input: aval_to_edit['is_pf'] = (new_is_pf_input == 's')

                            while True:
                                try:
                                    new_peso_str = input(f"      Novo peso % (atual: {(aval_to_edit.get('peso',0) or 0)*100:.1f}): ").strip()
                                    if new_peso_str:
                                        new_peso = float(new_peso_str)
                                        if 0.0 <= new_peso <= 100.0:
                                            aval_to_edit['peso'] = new_peso / 100.0
                                            break
                                        else: print("        Peso deve ser entre 0 e 100.")
                                    else: break
                                except ValueError: print("        Valor inv√°lido para peso.")

                            new_nota_str = input(f"      Nova nota (atual: {aval_to_edit.get('nota', 'N/A')}): ").strip()
                            if new_nota_str:
                                try:
                                    aval_to_edit['nota'] = float(new_nota_str)
                                    aval_to_edit['faltante'] = False
                                except ValueError:
                                    aval_to_edit['nota'] = None
                                    aval_to_edit['faltante'] = True
                                    print("        Nota inv√°lida, ser√° 'n√£o realizada'.")
                            elif new_nota_str == "":
                                aval_to_edit['nota'] = None
                                aval_to_edit['faltante'] = True

                            print(f"      Avalia√ß√£o '{aval_to_edit['nome']}' atualizada.")
                            break
                        else: print(f"    N√∫mero inv√°lido. Deve ser entre 1 e {len(temp_avals_for_disc)}.")
                    except ValueError: print("    Entrada inv√°lida para n√∫mero.")

        if edit_avals in ['r', 'a']:
            while True:
                aval_nome_input = input("    Nome da avalia√ß√£o (ou 'fim'): ").strip()
                if aval_nome_input.lower() == 'fim': break
                if not aval_nome_input: print("     Nome da avalia√ß√£o n√£o pode ser vazio."); continue

                aval_nome_norm = aval_nome_input.title()
                is_pf_input = input(f"    '{aval_nome_norm}' √© a Prova Final (PF)? (S/N): ").strip().lower()
                is_pf_aval = (is_pf_input == 's')

                aval_peso_percent = -1.0
                while not (0.0 <= aval_peso_percent <= 100.0):
                    try:
                        aval_peso_str = input(f"    Peso percentual de '{aval_nome_norm}' (0-100, ex: 30): ").strip()
                        aval_peso_percent = float(aval_peso_str)
                        if not (0.0 <= aval_peso_percent <= 100.0): print("      Peso deve ser entre 0 e 100.")
                    except ValueError: print("      Valor inv√°lido para peso.")

                nota_str = input(f"    Nota obtida em '{aval_nome_norm}' (deixe em branco se ainda n√£o feita): ").strip()
                nota, faltante = (None, True)
                if nota_str:
                    try: nota, faltante = (float(nota_str), False)
                    except ValueError: print("      Nota inv√°lida, ser√° 'n√£o realizada'.")

                new_aval_data = {'nome': aval_nome_norm, 'peso': aval_peso_percent/100.0, 'nota': nota, 'faltante': faltante, 'is_pf': is_pf_aval}

                existing_aval_index = next((idx for idx, ex_aval in enumerate(temp_avals_for_disc) if ex_aval['nome'].title() == aval_nome_norm), -1)
                if edit_avals == 'a' and existing_aval_index != -1:
                    print(f"      Avalia√ß√£o '{aval_nome_norm}' j√° existe. N√£o foi adicionada. Use (E)ditar ou (R)einserir.")
                else:
                    if existing_aval_index != -1 and edit_avals == 'r':
                        temp_avals_for_disc[existing_aval_index] = new_aval_data
                        print(f"      Avalia√ß√£o '{aval_nome_norm}' (reinserida/substitu√≠da).")
                    elif existing_aval_index != -1 and edit_avals == 'a':
                         print(f"      Avalia√ß√£o '{aval_nome_norm}' j√° existe. Use (E)ditar ou (R)einserir.")
                    else:
                        temp_avals_for_disc.append(new_aval_data)
                        print(f"      Avalia√ß√£o '{aval_nome_norm}' adicionada.")

        disc_atual['avaliacoes'] = temp_avals_for_disc

        final_sum_pesos = sum(aval.get('peso', 0) or 0 for aval in disc_atual.get('avaliacoes', []))
        if abs(final_sum_pesos - 1.0) > 1e-2 and final_sum_pesos > 0:
            print(f"  Aten√ß√£o Final: O peso total das avalia√ß√µes para '{disc_nome_original}' √© {final_sum_pesos*100:.1f}%. Idealmente, deveria ser 100%.")

        disc_atual['avaliacoes_faltantes'] = [a['nome'] for a in disc_atual.get('avaliacoes', []) if (a.get('faltante', True) or a.get('nota') is None) and not a.get('is_pf', False)]

    save_student_data(student_id, student_data)
    print("\nValida√ß√£o e complementa√ß√£o conclu√≠das. Dados salvos.")
    return student_data

# --- M√≥dulo 4: An√°lise Detalhada da Situa√ß√£o Acad√™mica (com LLM) ---

def calculate_current_weighted_score_and_weights(avaliacoes):
    soma_nota_peso = 0
    soma_pesos_com_nota = 0
    soma_total_pesos_sem_pf = 0
    peso_pf = 0
    pf_obj = None

    for aval in avaliacoes:
        peso = aval.get('peso', 0) or 0
        if aval.get('is_pf'):
            peso_pf = peso
            pf_obj = aval
        else:
            soma_total_pesos_sem_pf += peso
            if aval.get('nota') is not None and not aval.get('faltante'):
                soma_nota_peso += aval['nota'] * peso
                soma_pesos_com_nota += peso
    return soma_nota_peso, soma_pesos_com_nota, soma_total_pesos_sem_pf, peso_pf, pf_obj

def llm_analyze_discipline_for_pf(discipline_name, discipline_data, student_name="estudante"):
    if not GEMINI_MODEL:
        print("LLM n√£o configurada. N√£o √© poss√≠vel analisar para PF.")
        return None

    prompt = f"""
    Voc√™ √© um mentor educacional para estudantes do ensino m√©dio, como um "irm√£o mais velho" experiente, paciente e compreensivo.
    Seu papel √© acolher, orientar e acompanhar o aluno nos estudos.
    O aluno se chama {student_name}.

    Para a disciplina '{discipline_name}', os dados s√£o:
    M√©dia m√≠nima para aprova√ß√£o: {discipline_data.get('media_minima')}
    F√≥rmula de c√°lculo (informativo): {discipline_data.get('formula', 'ponderada')}
    Avalia√ß√µes: {json.dumps(discipline_data.get('avaliacoes', []), ensure_ascii=False)}

    Tarefa:
    1. Identifique a(s) avalia√ß√£o(√µes) marcada(s) como Prova Final ('is_pf': true). Se houver mais de uma, considere a de maior peso ou a primeira. Se n√£o houver, mas houver avalia√ß√µes com nota nula e peso, e a soma dos pesos for 1.0, considere a avalia√ß√£o faltante de maior peso como a PF para este c√°lculo. Se n√£o houver PF expl√≠cita e a soma dos pesos das avalia√ß√µes existentes for menor que 1.0, assuma que o peso restante (1.0 - soma_pesos_existentes) √© para uma Prova Final impl√≠cita.
    2. Para CADA avalia√ß√£o que N√ÉO SEJA A Prova Final e que esteja com nota nula ('faltante': true, 'nota': null), estime uma nota. Baseie a estimativa na m√©dia das notas j√° obtidas nas outras avalia√ß√µes (que n√£o sejam PF) desta disciplina. Se n√£o houver notas anteriores, estime como {discipline_data.get('media_minima', 6.0)}.
    3. Calcule a nota EXATA que o aluno precisa tirar na Prova Final para atingir a m√©dia m√≠nima de aprova√ß√£o. Considere as notas j√° obtidas e as notas ESTIMADAS para as avalia√ß√µes intermedi√°rias faltantes.
    4. Se a nota necess√°ria na PF for > 10.0 ou < 0.0, indique isso.
    5. **Elabore a 'explicacao_calculo' de forma clara, did√°tica e emp√°tica, como se estivesse conversando com {student_name}.** Explique o que as notas estimadas significam e como chegou √† nota da PF. Se for imposs√≠vel, explique com cuidado. Se j√° estiver aprovado, parabenize!
       Exemplo de tom para explica√ß√£o: "Olha, {student_name}, pra gente entender como voc√™ est√° em {discipline_name}, eu dei uma olhada nas suas notas. Naquele trabalho que ainda n√£o tem nota, imaginei que voc√™ tiraria um X, baseado no seu desempenho at√© agora. Com isso em mente, pra passar na Prova Final, voc√™ precisaria de um Y. Fica tranquilo(a) que a gente vai ver como chegar l√°!"

    Retorne a resposta APENAS no formato JSON abaixo. N√ÉO inclua nenhum texto antes ou depois do JSON.
    {{
      "disciplina": "{discipline_name}",
      "media_minima": {discipline_data.get('media_minima')},
      "avaliacoes_com_estimativas": [
        {{ "nome": "Nome Avalia√ß√£o 1", "nota_original": 7.5, "nota_estimada": null, "peso": 0.3, "is_pf": false }},
        {{ "nome": "Nome Avalia√ß√£o Faltante 1", "nota_original": null, "nota_estimada": 6.0, "peso": 0.2, "is_pf": false }},
        {{ "nome": "Prova Final", "nota_original": null, "nota_estimada": null, "peso": 0.5, "is_pf": true }}
      ],
      "nota_necessaria_pf": "X.XX",
      "explicacao_calculo": "Sua explica√ß√£o emp√°tica aqui...",
      "situacao_pf": "Cr√≠tica | Aten√ß√£o Elevada | Aten√ß√£o | Confort√°vel | J√° Aprovado | J√° Reprovado"
    }}
    """
    try:
        print(f"  Enviando '{discipline_name}' para an√°lise da LLM (c√°lculo de PF)...")
        response = GEMINI_MODEL.generate_content(prompt)
        return extract_json_from_llm_response(response.text)
    except Exception as e:
        print(f"  Erro ao chamar LLM para '{discipline_name}': {e}")
        return None

def analyze_academic_situation(student_id, student_data):
    print("\nüìä Passo de An√°lise Detalhada da Situa√ß√£o Acad√™mica (com LLM)")
    analysis_results_llm = {}
    if 'disciplinas' not in student_data or not student_data['disciplinas']:
        print("Nenhuma disciplina para analisar.")
        return analysis_results_llm

    for disc_nome, disc_data in student_data['disciplinas'].items():
        print(f"\n--- Analisando Disciplina: {disc_nome} ---")
        media_minima = disc_data.get('media_minima')
        avaliacoes = disc_data.get('avaliacoes', [])

        if media_minima is None:
            print("  M√©dia m√≠nima n√£o definida. An√°lise LLM para PF n√£o ser√° realizada.")
            analysis_results_llm[disc_nome] = {
                'disciplina': disc_nome,
                'media_minima': None,
                'nota_necessaria_pf': "N/A",
                'explicacao_calculo': "M√©dia m√≠nima n√£o informada.",
                'situacao_pf': "Indefinida",
                'avaliacoes_com_estimativas': avaliacoes
            }
            continue

        has_pf = any(a.get('is_pf') for a in avaliacoes)
        pf_com_nota = any(a.get('is_pf') and a.get('nota') is not None for a in avaliacoes)
        intermediarias_faltando = any(not a.get('is_pf') and (a.get('nota') is None or a.get('faltante')) for a in avaliacoes)


        if not has_pf:
             print(f"  Disciplina '{disc_nome}' n√£o tem Prova Final (PF) definida. C√°lculo de nota para PF n√£o aplic√°vel.")
             soma_nota_peso, soma_pesos_com_nota, _, _, _ = calculate_current_weighted_score_and_weights(avaliacoes)
             media_atual = (soma_nota_peso / soma_pesos_com_nota) if soma_pesos_com_nota > 0 else 0
             situacao = "Aprovado" if media_atual >= media_minima else "Reprovado"
             if any((a.get('nota') is None or a.get('faltante')) for a in avaliacoes):
                 situacao = "Em Andamento (sem PF)"

             analysis_results_llm[disc_nome] = {
                'disciplina': disc_nome,
                'media_minima': media_minima,
                'nota_necessaria_pf': "N/A (Sem PF)",
                'explicacao_calculo': f"Sem PF definida. M√©dia atual com notas lan√ßadas: {media_atual:.2f}",
                'situacao_pf': situacao,
                'avaliacoes_com_estimativas': avaliacoes
             }
             print(f"  Situa√ß√£o: {situacao} (M√©dia atual: {media_atual:.2f})")
             continue


        if pf_com_nota and not intermediarias_faltando:
            print(f"  Todas as notas, incluindo PF, parecem lan√ßadas para '{disc_nome}'. N√£o √© necess√°rio c√°lculo de PF pela LLM.")
            soma_nota_peso_total = sum( (a.get('nota',0) or 0) * (a.get('peso',0) or 0) for a in avaliacoes if a.get('nota') is not None )
            soma_pesos_total_com_nota = sum(a.get('peso',0) or 0 for a in avaliacoes if a.get('nota') is not None)
            media_final_calculada = (soma_nota_peso_total / soma_pesos_total_com_nota) if soma_pesos_total_com_nota > 0 else 0.0
            situacao = "Aprovado" if media_final_calculada >= media_minima else "Reprovado"

            soma_total_pesos_disciplina = sum(a.get('peso',0) or 0 for a in avaliacoes)
            if abs(soma_total_pesos_disciplina - 1.0) > 0.01 and soma_total_pesos_disciplina > 0 :
                situacao += " (Aten√ß√£o: Pesos n√£o somam 100% ou nem todas as notas lan√ßadas com peso foram consideradas)"


            analysis_results_llm[disc_nome] = {
                'disciplina': disc_nome,
                'media_minima': media_minima,
                'nota_necessaria_pf': f"Nota PF j√° lan√ßada ({[a['nota'] for a in avaliacoes if a.get('is_pf') and a.get('nota') is not None][0]:.2f})",
                'explicacao_calculo': f"Todas as notas lan√ßadas. M√©dia final calculada: {media_final_calculada:.2f}",
                'situacao_pf': situacao,
                'avaliacoes_com_estimativas': avaliacoes
            }
            print(f"  Situa√ß√£o: {situacao} (M√©dia final: {media_final_calculada:.2f})")
            continue

        llm_result = llm_analyze_discipline_for_pf(disc_nome, disc_data, student_data.get('nome', 'estudante'))

        if llm_result and "nota_necessaria_pf" in llm_result:
            analysis_results_llm[disc_nome] = llm_result
            print(f"  LLM An√°lise para '{disc_nome}':")
            print(f"    M√©dia M√≠nima: {llm_result.get('media_minima')}")
            if llm_result.get('avaliacoes_com_estimativas'):
                print("    Avalia√ß√µes (com estimativas se aplic√°vel):")
                for aval in llm_result['avaliacoes_com_estimativas']:
                    nota_str = f"{aval.get('nota_original')}"
                    if aval.get('nota_estimada') is not None:
                        nota_str += f" (Estimada pela gente: {aval['nota_estimada']})"
                    elif aval.get('nota_original') is None:
                        nota_str = "Ainda n√£o feita"
                    is_pf_str = " (PF)" if aval.get('is_pf') else ""
                    print(f"      - {aval['nome']}{is_pf_str}: {nota_str}, Peso: {aval.get('peso',0)*100:.0f}%")
            print(f"    Nota Necess√°ria na PF: {llm_result.get('nota_necessaria_pf')}")
            print(f"    Situa√ß√£o PF: {llm_result.get('situacao_pf')}")
            # MODIFICA√á√ÉO AQUI:
            explicacao_formatada = textwrap.fill(llm_result.get('explicacao_calculo', "Sem explica√ß√£o da LLM."), width=100, initial_indent="    Mentor diz: \"", subsequent_indent="    ")
            print(explicacao_formatada + "\"") # Adiciona aspas finais
        else:
            print(f"  Falha ao obter an√°lise da LLM para '{disc_nome}'.")
            analysis_results_llm[disc_nome] = {
                'disciplina': disc_nome, 'media_minima': media_minima,
                'nota_necessaria_pf': "Erro LLM", 'explicacao_calculo': "N√£o consegui calcular direitinho com a IA desta vez, podemos tentar de novo ou verificar os dados.",
                'situacao_pf': "Indefinida (Erro LLM)", 'avaliacoes_com_estimativas': avaliacoes
            }

    if GEMINI_MODEL and analysis_results_llm:
        disciplines_for_summary = []
        for dn, dr in analysis_results_llm.items():
            if dr.get('nota_necessaria_pf') not in ["N/A", "N/A (Sem PF)", "Erro LLM"] :
                 disciplines_for_summary.append({
                     "disciplina": dn,
                     "nota_necessaria_pf": dr.get('nota_necessaria_pf'),
                     "situacao_pf": dr.get('situacao_pf')
                 })

        if disciplines_for_summary:
            prompt_summary = f"""
            Voc√™ √© um mentor educacional para estudantes do ensino m√©dio, como um "irm√£o mais velho" experiente, paciente e compreensivo.
            Seu papel √© acolher, orientar e acompanhar o aluno nos estudos. O aluno se chama {student_data.get('nome', 'estudante')}.

            Com base nos seguintes resultados de an√°lise de disciplinas, onde √© mostrada a nota necess√°ria na Prova Final (PF) para atingir a m√©dia:
            {json.dumps(disciplines_for_summary, ensure_ascii=False, indent=2)}

            Produza um resumo conciso, em texto simples (n√£o JSON), priorizando as disciplinas que exigem maior esfor√ßo ou aten√ß√£o na PF.
            **Use um tom encorajador e de apoio, como se estivesse conversando com {student_data.get('nome', 'estudante')}.**
            Ordene as disciplinas da mais cr√≠tica/dif√≠cil para a mais tranquila em termos de nota na PF.
            Destaque as 3 a 5 mais importantes e explique brevemente porqu√™ (ex: "Em Matem√°tica, parece que a gente vai precisar de um g√°s extra na PF, mas t√¥ aqui pra ajudar!").
            Se alguma for imposs√≠vel (nota > 10 na PF ou string indicando impossibilidade), mencione isso com cuidado e ofere√ßa alternativas ou apoio (ex: "Olha, em Qu√≠mica a conta pra PF ficou bem alta, o que significa que talvez n√£o d√™ pra alcan√ßar s√≥ com ela. Mas n√£o se preocupe, vamos ver o que mais podemos fazer, talvez focar em recuperar outras notas ou conversar com o professor.").
            Se alguma j√° estiver aprovada independente da PF (situa√ß√£o "J√° Aprovado"), parabenize! (ex: "E a√≠, {student_data.get('nome', 'estudante')}, boa not√≠cia! Em Hist√≥ria voc√™ j√° est√° mandando super bem, parece que j√° garantiu a aprova√ß√£o! Show!")
            """
            try:
                print("\nGerando resumo priorizado das disciplinas com LLM...")
                response_summary = GEMINI_MODEL.generate_content(prompt_summary)
                student_data['resumo_priorizado_llm'] = response_summary.text
                print("\nüìã Resumo Priorizado das Disciplinas (LLM):")
                # MODIFICA√á√ÉO AQUI:
                print(textwrap.fill(response_summary.text, width=100))
            except Exception as e:
                print(f"Erro ao gerar resumo priorizado com LLM: {e}")
                student_data['resumo_priorizado_llm'] = "N√£o foi poss√≠vel gerar o resumo priorizado."
        else:
            print("\nNenhuma disciplina com dados suficientes para gerar resumo priorizado de PF.")
            student_data['resumo_priorizado_llm'] = "Sem dados para resumo."


    save_student_data(student_id, student_data)
    return analysis_results_llm


# --- M√≥dulo 5: Gera√ß√£o de Plano de Estudos com LLM ---
def parse_time_range(time_range_str):
    match = re.fullmatch(r"(\d{1,2}:\d{2})-(\d{1,2}:\d{2})", time_range_str.strip())
    if not match:
        return None, None, 0

    start_str, end_str = match.groups()
    try:
        start_time_obj = datetime.strptime(start_str, "%H:%M").time()
        end_time_obj = datetime.strptime(end_str, "%H:%M").time()

        today = datetime.today().date()
        start_dt = datetime.combine(today, start_time_obj)
        end_dt = datetime.combine(today, end_time_obj)

        if end_dt <= start_dt:
            end_dt += timedelta(days=1) # Assume que cruza a meia-noite

        duration = end_dt - start_dt
        duration_hours = duration.total_seconds() / 3600
        if duration_hours <= 0:
             return None, None, 0
        return start_time_obj, end_time_obj, duration_hours
    except ValueError:
        return None, None, 0

def get_study_availability():
    print("\nüóìÔ∏è Coleta de Disponibilidade Semanal para Estudos Extras")
    print("   Por favor, informe os per√≠odos de estudo para cada dia.")
    print("   Use o formato HH:MM-HH:MM (ex: 18:00-20:30).")
    print("   Se tiver mais de um per√≠odo no mesmo dia, separe por v√≠rgula (ex: 09:00-11:00, 14:00-16:00).")
    print("   Deixe em branco se n√£o houver disponibilidade no dia.")

    availability_details = {}
    total_hours_study = 0
    days_of_week = ["Segunda", "Ter√ßa", "Quarta", "Quinta", "Sexta", "S√°bado", "Domingo"]

    for day in days_of_week:
        availability_details[day] = []
        while True:
            input_str = input(f"  Disponibilidade na {day}: ").strip()
            if not input_str:
                break

            period_strings = [p.strip() for p in input_str.split(',')]
            valid_periods_for_day_input = []
            all_periods_valid_for_day = True

            for period_str in period_strings:
                start_t, end_t, duration_h = parse_time_range(period_str)
                if duration_h > 0:
                    valid_periods_for_day_input.append({
                        "inicio_str": start_t.strftime("%H:%M"),
                        "fim_str": end_t.strftime("%H:%M"),
                        "duracao_horas": duration_h
                    })
                else:
                    print(f"    Formato inv√°lido ('{period_str}') ou dura√ß√£o zero/negativa. Use HH:MM-HH:MM com fim ap√≥s in√≠cio.")
                    all_periods_valid_for_day = False
                    break

            if all_periods_valid_for_day:
                availability_details[day].extend(valid_periods_for_day_input)
                break
            else:
                print(f"    Por favor, reinsira a disponibilidade para {day}.")
                availability_details[day] = []

    for day_name, periods in availability_details.items():
        for period in periods:
            total_hours_study += period['duracao_horas']

    if total_hours_study == 0:
        print("\nVoc√™ n√£o indicou nenhuma disponibilidade. N√£o ser√° poss√≠vel gerar um plano de estudos detalhado.")
        return None

    print(f"\nTotal de horas de estudo semanais dispon√≠veis: {total_hours_study:.1f} horas.")
    return availability_details


def generate_llm_detailed_study_plan(student_data, analysis_results, availability_details):
    if not GEMINI_MODEL:
        print("LLM n√£o configurada. N√£o √© poss√≠vel gerar o plano de estudos detalhado.")
        return None
    if not availability_details or sum(sum(p['duracao_horas'] for p in periods) for periods in availability_details.values() if periods) == 0:
        print("Disponibilidade de estudo n√£o fornecida ou zerada. Plano n√£o gerado.")
        return None
    if not analysis_results:
        print("An√°lise acad√™mica n√£o dispon√≠vel. Plano n√£o gerado.")
        return None

    disciplinas_para_plano = []
    for disc_nome, result in analysis_results.items():
        nota_pf = result.get('nota_necessaria_pf')
        situacao = result.get('situacao_pf', 'Indefinida')

        if isinstance(nota_pf, (float, int)) or (isinstance(nota_pf, str) and "imposs√≠vel" not in nota_pf.lower() and "n/a" not in nota_pf.lower()):
            if situacao not in ["J√° Aprovado", "Confort√°vel", "N/A (Sem PF)"]:
                 disciplinas_para_plano.append({
                     "nome": disc_nome,
                     "nota_necessaria_pf": nota_pf,
                     "situacao_pf": situacao,
                     "bncc_topics": get_bncc_topics(student_data.get('serie'), disc_nome)
                 })
        elif isinstance(nota_pf, str) and "imposs√≠vel" in nota_pf.lower():
            disciplinas_para_plano.append({
                     "nome": disc_nome,
                     "nota_necessaria_pf": nota_pf,
                     "situacao_pf": situacao,
                     "bncc_topics": get_bncc_topics(student_data.get('serie'), disc_nome)
                 })


    if not disciplinas_para_plano:
        print("Nenhuma disciplina parece precisar de foco para Prova Final no momento ou os dados s√£o insuficientes. Plano n√£o gerado.")
        return None

    def sort_key_disciplinas(d):
        nota = d['nota_necessaria_pf']
        if isinstance(nota, str):
            if "imposs√≠vel" in nota.lower() or ('>' in nota and re.search(r"[-+]?\d*\.\d+|\d+", nota) and float(re.findall(r"[-+]?\d*\.\d+|\d+", nota)[0]) > 10):
                return float('-inf')
            return 0
        if nota is None: return float('inf')
        return -float(nota)

    disciplinas_para_plano.sort(key=sort_key_disciplinas)

    prompt_availability = {}
    days_of_week_map = {"Segunda": "Segunda-feira", "Ter√ßa": "Ter√ßa-feira", "Quarta": "Quarta-feira", "Quinta": "Quinta-feira", "Sexta": "Sexta-feira", "S√°bado": "S√°bado", "Domingo": "Domingo"}
    for day, periods in availability_details.items():
        day_key = days_of_week_map.get(day, day) # Usa o nome completo do dia da semana
        if periods:
            prompt_availability[day_key] = [f"{p['inicio_str']}-{p['fim_str']}" for p in periods]


    prompt_plan = f"""
    Voc√™ √© um planejador de estudos especialista para alunos do Ensino M√©dio, com um tom de "irm√£o mais velho" experiente e compreensivo.
    O aluno se chama {student_data.get('nome', 'estudante')}.

    Dados do aluno:
    - S√©rie: {student_data.get('serie')}
    - Disponibilidade semanal para estudos (per√≠odos espec√≠ficos por dia):
      {json.dumps(prompt_availability, ensure_ascii=False, indent=2)}
    - Disciplinas priorit√°rias (com nota necess√°ria na Prova Final e t√≥picos BNCC relevantes):
      {json.dumps(disciplinas_para_plano, ensure_ascii=False, indent=2)}

    Tarefa:
    Crie um plano de estudos semanal DETALHADO para o aluno, {student_data.get('nome', 'estudante')}.
    1.  **Utilize APENAS os per√≠odos de estudo informados pelo aluno.** Distribua as disciplinas priorit√°rias dentro desses hor√°rios.
    2.  D√™ mais tempo para as disciplinas mais cr√≠ticas (maior nota necess√°ria na PF ou situa√ß√£o 'Cr√≠tica'/'Aten√ß√£o Elevada'/'Imposs√≠vel').
    3.  Para cada bloco de estudo, especifique:
        - 'dia_semana': (ex: "Segunda-feira") - Use os nomes dos dias como fornecidos na disponibilidade (Segunda-feira, Ter√ßa-feira, etc.).
        - 'horario_inicio': (ex: "18:00")
        - 'horario_fim': (ex: "19:30")
        - 'disciplina': Nome da disciplina. Se for uma pausa ou refei√ß√£o, pode ser "Pausa" ou "Refei√ß√£o".
        - 'atividade_sugerida': Uma atividade espec√≠fica e motivadora (ex: "Bora detonar em [T√≥pico BNCC XYZ]!", "Que tal resolver uns desafios de [assunto] pra ficar craque?", "Vamos fazer um esquenta pra PF com uns exerc√≠cios tipo simulado?", "Uma leitura r√°pida e focada do resumo do cap√≠tulo X pra clarear as ideias."). Para pausas, "Pequena pausa para esticar as pernas e tomar uma √°gua!" ou "Hora do lanche!". Seja criativo, variado e use um tom encorajador. Se houver t√≥picos BNCC, tente us√°-los.
        - 'tipo_bloco': "Estudo" ou "Pausa" ou "Refei√ß√£o".
    4.  Incorpore pausas curtas (10-15 min) a cada 50-90 minutos de estudo DENTRO dos per√≠odos dispon√≠veis. Se um per√≠odo for curto (ex: 1h), talvez uma pausa n√£o seja necess√°ria ou pode ser ao final.
    5.  Se os blocos de estudo se estenderem por hor√°rios t√≠picos de refei√ß√£o (ex: 12:00-14:00, 19:00-20:30) E o aluno tiver disponibilidade nesses hor√°rios, sugira uma pausa para refei√ß√£o.
    6.  O plano deve ser realista e ajudar {student_data.get('nome', 'estudante')} a se preparar para as Provas Finais.
    7.  **N√£o crie blocos de estudo fora dos hor√°rios de disponibilidade informados.** Certifique-se que horario_fim de um bloco n√£o exceda o fim do per√≠odo de disponibilidade do dia.

    Retorne o plano APENAS como um array JSON de objetos. Cada objeto √© um bloco no plano. Exemplo de um bloco:
    {{ "dia_semana": "Segunda-feira", "horario_inicio": "18:00", "horario_fim": "18:50", "disciplina": "Matem√°tica", "atividade_sugerida": "Revisar Teorema de Pit√°goras (EM13MAT101)", "tipo_bloco": "Estudo" }}
    N√ÉO inclua nenhum texto antes ou depois do array JSON.
    """

    try:
        print("\nGerando plano de estudos detalhado com LLM (isso pode levar um momento)...")
        response_plan = GEMINI_MODEL.generate_content(prompt_plan)
        plan_json = extract_json_from_llm_response(response_plan.text)

        if plan_json and isinstance(plan_json, list) and len(plan_json) > 0:
            print("\nüìÖ Plano de Estudos Semanal Detalhado (Sugest√£o da LLM):")
            df_plano = pd.DataFrame(plan_json)
            if not df_plano.empty:
                days_order_ics = ["Segunda-feira", "Ter√ßa-feira", "Quarta-feira", "Quinta-feira", "Sexta-feira", "S√°bado", "Domingo"]
                try:
                    # Garantir que 'dia_semana' exista antes de tentar categorizar
                    if 'dia_semana' in df_plano.columns and 'horario_inicio' in df_plano.columns:
                        df_plano['dia_semana_cat'] = pd.Categorical(df_plano['dia_semana'], categories=days_order_ics, ordered=True)
                        df_plano.sort_values(by=['dia_semana_cat', 'horario_inicio'], inplace=True)
                        df_plano.drop(columns=['dia_semana_cat'], inplace=True)
                    elif 'dia_semana' in df_plano.columns: # Ordenar apenas por dia se hor√°rio n√£o existir
                         df_plano['dia_semana_cat'] = pd.Categorical(df_plano['dia_semana'], categories=days_order_ics, ordered=True)
                         df_plano.sort_values(by=['dia_semana_cat'], inplace=True)
                         df_plano.drop(columns=['dia_semana_cat'], inplace=True)
                except KeyError:
                    print("Aviso: Colunas esperadas ('dia_semana', 'horario_inicio') podem n√£o estar completas no plano da LLM para ordena√ß√£o.")
                except Exception as e_sort:
                    print(f"Aviso: n√£o foi poss√≠vel ordenar o plano detalhadamente ({e_sort}).")

                print(df_plano.to_string(index=False))

                export_choice = input("\nDeseja exportar este plano? (xlsx/ics/N): ").strip().lower()
                student_file_prefix = student_data.get('id', 'aluno')
                if export_choice == 'xlsx':
                    filename_xlsx = f"{student_file_prefix}_plano_estudos_detalhado.xlsx"
                    try:
                        df_plano.to_excel(filename_xlsx, index=False)
                        files.download(filename_xlsx)
                        print(f"Plano exportado: '{filename_xlsx}'")
                    except Exception as e: print(f"Erro ao exportar para XLSX: {e}")
                elif export_choice == 'ics':
                    filename_ics = f"{student_file_prefix}_plano_estudos_detalhado.ics"
                    cal = Calendar()
                    today_date = datetime.now().date()

                    days_map_python = {
                        "segunda-feira": 0, "ter√ßa-feira": 1, "quarta-feira": 2,
                        "quinta-feira": 3, "sexta-feira": 4, "s√°bado": 5, "domingo": 6
                    }

                    for _, tarefa in df_plano.iterrows():
                        try:
                            dia_str_tarefa = tarefa.get('dia_semana','').strip().lower()
                            target_weekday_idx = days_map_python.get(dia_str_tarefa)

                            if target_weekday_idx is None:
                                print(f"Aviso: Dia da semana '{tarefa.get('dia_semana')}' n√£o reconhecido para evento ICS. Pulando.")
                                continue

                            current_weekday = today_date.weekday()
                            days_diff = target_weekday_idx - current_weekday
                            if days_diff < 0: days_diff += 7
                            event_date = today_date + timedelta(days=days_diff)

                            start_time_str = tarefa.get('horario_inicio', '09:00')
                            end_time_str = tarefa.get('horario_fim', '10:00')

                            start_h, start_m = map(int, start_time_str.split(':'))
                            end_h, end_m = map(int, end_time_str.split(':'))

                            begin_dt = datetime.combine(event_date, time(start_h, start_m))
                            end_dt = datetime.combine(event_date, time(end_h, end_m))

                            if end_dt <= begin_dt:
                                end_dt = begin_dt + timedelta(hours=1)

                            evt_name = f"{tarefa.get('tipo_bloco', 'Evento').title()}: {tarefa.get('disciplina', '')}"
                            if tarefa.get('tipo_bloco', '').lower() == "estudo":
                                evt_name = f"Estudar: {tarefa.get('disciplina', 'N√£o especificado')}"
                            elif tarefa.get('tipo_bloco', '').lower() == "pausa":
                                evt_name = f"Pausa: {tarefa.get('atividade_sugerida', 'Descanso')}"
                            elif tarefa.get('tipo_bloco', '').lower() == "refei√ß√£o":
                                evt_name = f"Refei√ß√£o: {tarefa.get('atividade_sugerida', 'Alimenta√ß√£o')}"

                            event_obj = Event(name=evt_name,
                                          description=tarefa.get('atividade_sugerida', ''),
                                          begin=begin_dt,
                                          end=end_dt)
                            cal.events.add(event_obj)
                        except Exception as e_ics_event:
                            print(f"Erro ao criar evento ICS para tarefa '{tarefa.get('disciplina')}': {e_ics_event}")
                            print(f"Dados da tarefa: {tarefa.to_dict()}")
                    try:
                        with open(filename_ics, 'w', encoding='utf-8') as f: f.writelines(cal.serialize_iter())
                        files.download(filename_ics)
                        print(f"Plano exportado como '{filename_ics}'")
                    except Exception as e: print(f"Erro ao exportar para ICS: {e}")
            else:
                print("A LLM n√£o retornou um plano de estudos v√°lido em formato de tabela ou a lista estava vazia.")
            return df_plano
        else:
            print("A LLM n√£o retornou um JSON v√°lido ou a lista estava vazia para o plano de estudos.")
            print("Resposta da LLM (in√≠cio):", response_plan.text[:500] if response_plan.text else "Vazio")
            return None

    except Exception as e:
        print(f"Erro ao gerar plano de estudos com LLM: {e}")
        return None
    return None

# --- M√≥dulo 6: Encorajamento e Pr√≥ximos Passos ---
def final_encouragement(student_data, analysis_results):
    print("\nüí¨ Passo de Encorajamento Realista e Pr√≥ximos Passos")
    nome_aluno = student_data.get('nome', 'Estudante')

    if not analysis_results:
        print(f"Ol√°, {nome_aluno}! Lembre-se de registrar suas notas e passar pela an√°lise para podermos tra√ßar um plano mais eficaz. Estou aqui para ajudar!")
        return

    resumo_priorizado = student_data.get('resumo_priorizado_llm')
    if resumo_priorizado and resumo_priorizado not in ["N√£o foi poss√≠vel gerar o resumo priorizado.", "Sem dados para resumo."]:
        print(f"\nEnt√£o, {nome_aluno}, pra fechar nossa conversa de hoje, aqui vai um resumo do que a gente viu:")
        # MODIFICA√á√ÉO AQUI:
        print(textwrap.fill(resumo_priorizado, width=100))
        print(f"\nLembre-se, {nome_aluno}, este √© um guia pra te ajudar a organizar os estudos. O mais importante √© voc√™ encontrar o que funciona melhor pra voc√™ e n√£o desistir, t√° bom? Qualquer coisa, √© s√≥ me chamar!")
        print("Com foco e sua dedica√ß√£o, voc√™ vai longe! Acredito em voc√™! üí™ Bora pra cima!")
    else:
        situacao_geral, disc_exemplo = "Confort√°vel/OK", None
        for disc_nome, result in analysis_results.items():
            sit_pf = result.get('situacao_pf', 'Indefinida')
            if sit_pf == "Cr√≠tica": situacao_geral, disc_exemplo = "Cr√≠tica", disc_nome; break
            if sit_pf in ["Aten√ß√£o Elevada", "Aten√ß√£o"] and situacao_geral != "Cr√≠tica":
                situacao_geral, disc_exemplo = "Aten√ß√£o", disc_nome

        fallback_message = ""
        if situacao_geral == "Cr√≠tica":
            msg_disciplina = f" principalmente em {disc_exemplo}" if disc_exemplo else " em algumas mat√©rias"
            fallback_message = (f"Olha, {nome_aluno}, sei que a situa√ß√£o parece um pouco apertada{msg_disciplina}, mas n√£o √© hora de desanimar, viu?\n"
                                f"Pensa que cada esforcinho agora faz uma diferen√ßa enorme l√° na frente! üí™ Com o plano que a gente montou e seu foco, d√° pra virar o jogo. T√¥ aqui na torcida e pra te ajudar no que precisar. Vamos juntos nessa!")
        elif situacao_geral == "Aten√ß√£o":
            msg_disciplina = f", como em {disc_exemplo}," if disc_exemplo else ""
            fallback_message = (f"A√≠ sim, {nome_aluno}! Voc√™ t√° no caminho certo, mandando bem! Algumas mat√©rias{msg_disciplina} v√£o pedir um pouquinho mais da sua aten√ß√£o agora, mas √© super normal.\n"
                                f"Com o plano e sua dedica√ß√£o, tenho certeza que voc√™ vai tirar de letra. Mantenha esse ritmo bom! Se precisar ajustar alguma coisa ou tiver alguma d√∫vida, √© s√≥ me chamar, combinado? üòâ")
        else:
            fallback_message = (f"Parab√©ns, {nome_aluno}! Pelo que vi aqui, sua situa√ß√£o acad√™mica est√° bem encaminhada ou n√£o tivemos todos os detalhes para uma an√°lise super profunda! ü•≥\n"
                                f"Se a gente fez um plano, √© pra continuar nesse pique ou dar aquele g√°s final. Continue assim que √© sucesso! E se algo mudar, me atualiza!")

        # MODIFICA√á√ÉO AQUI:
        print(textwrap.fill(fallback_message, width=100))


    print("\nLembre-se de voltar para atualizarmos seu progresso! At√© a pr√≥xima! üòä")


# --- Fluxo Principal de Execu√ß√£o ---
if __name__ == "__main__":
    mount_drive()

    student_id, student_data = collect_initial_info()

    student_data = collect_academic_info(student_id, student_data)

    analysis_results_llm = {}
    if student_data.get('disciplinas'):
        if any(d.get('media_minima') is not None for d_name, d in student_data['disciplinas'].items()):
            analysis_results_llm = analyze_academic_situation(student_id, student_data)
        else:
            print("\nAn√°lise acad√™mica n√£o realizada: nenhuma disciplina possui m√©dia m√≠nima definida. Por favor, valide os dados.")
    else:
        print("\nNenhuma informa√ß√£o de disciplina foi coletada para an√°lise.")

    study_plan_df = None
    if analysis_results_llm and GEMINI_MODEL:
        needs_planning = False
        for res_name, res_data in analysis_results_llm.items():
            sit_pf = res_data.get('situacao_pf', 'Indefinida')
            nota_pf = res_data.get('nota_necessaria_pf')
            if sit_pf not in ["J√° Aprovado", "N/A (Sem PF)", "Indefinida"] or \
               (isinstance(nota_pf, str) and "imposs√≠vel" in nota_pf.lower()):
                needs_planning = True
                break

        if needs_planning:
            availability = get_study_availability()
            if availability:
                study_plan_df = generate_llm_detailed_study_plan(student_data, analysis_results_llm, availability)
            else:
                print("\nPlano de estudos n√£o gerado pois n√£o foi informada disponibilidade semanal.")
        else:
            print("\nPlano de estudos n√£o gerado: todas as disciplinas parecem estar em situa√ß√£o confort√°vel, j√° aprovadas, ou n√£o necessitam de c√°lculo de Prova Final.")

    elif not GEMINI_MODEL and student_data.get('disciplinas'):
        print("\nPlano de estudos detalhado n√£o pode ser gerado pois a API da LLM n√£o est√° configurada.")
    elif not student_data.get('disciplinas'):
        print("\nPlano de estudos n√£o p√¥de ser gerado pois n√£o h√° dados de disciplinas.")


    final_encouragement(student_data, analysis_results_llm)

    print("\n--- Sess√£o Conclu√≠da ---")